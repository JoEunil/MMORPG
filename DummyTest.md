## Dummy client test

## 1. 개요
이 문서는 서버 성능 검증을 위해 사용되는 __더미 클라이언트 테스트(Dummy Client Test)__ 의 구조와 동작 방식에 대해 설명한다. 더미 클라이언트는 실제 사용자 행동을 단순화하여 시뮬레이션함으로써,  
서버가 특정 부하 조건에서 어떻게 동작하는지 측정하기 위한 도구이다.

## 2. 목적
게임 서버는 운영 환경에서 메모리 풀 고갈로 인해 추가 할당이 발생하면 성능 저하나 일시적 지연 같은 부하 문제가 발생할 수 있다.
따라서 서버가 감당 가능한 부하 수준을 사전에 식별하고, 메모리 관리 전략이 정상적으로 동작하는지 검증하기 위해 더미 클라이언트를 이용한 부하 테스트가 필요하다.

이 테스트를 통해 다음 항목을 관측할 수 있다:
- 서버 메모리 풀 사용량 변화
- 패킷 처리량 증가 시 TPS 변화
- 모니터링 시스템(Grafana + Loki + Promtail)과 연동한 실시간 성능 상태
- 예상 병목 지점(네트워크 IO, 로직 스레드 등)
> 운영 환경에서는 Prometheus와 같은 서버 메트릭 수집기를 통해 CPU, Memory, Network I/O 등 다양한 성능 지표를 수집·분석하는 것이 일반적이다.  
다만 본 테스트 환경은 단일 PC 기반의 로컬 테스트였기 때문에 별도의 메트릭 수집기를 구성하지 않았으며,  
기본적인 리소스 사용량은 Windows 작업관리자를 통해 확인하였다.


더미 클라이언트는 ClientCore 라이브러리의 네트워크 로직을 단순화하여 구현되며,
싱글 스레드 기반으로 최소 로직만 수행하도록 구성된다.

__더미 클라이언트의 동작 방식__
- 서버 최초 진입에 필요한 핸드셰이크/초기 응답 패킷만 정상 처리한다.
- 그 외의 게임 플레이 패킷은 모두 수신 후 즉시 폐기한다.
- 매 Tick마다 이동 패킷을 송신한다.
- 1.6초간격으로 채팅 패킷을 송신하여 일정한 메시지 처리 부하를 유지한다.

## 3. 테스트 결과 
![이미지 로드 실패](images/monitoring.png)
- 더미 클라이언트 100명으로 테스트를 진행했다.
- TPS는 안정적으로 유지되었으며, 객체 풀 또한 일정 수준에서 안정적으로 유지됨을 확인하였다.

테스트 환경이 4코어 PC 단일 장비였기 때문에,
로그인 서버, Redis, Loki, Grafana, Dummy Client 등 모든 구성 요소가 동일한 PC에서 동작하고 있었다.
그 결과 리소스 경쟁이 발생하여 __1000명 부하 테스트는 실패__ 하였다.

Process Explorer로 스레드 상태를 분석한 결과,  
특정 스레드가 과도하게 코어를 점유하는 현상은 없었으며,  
따라서 lock 경합이나 서버 구조상의 문제는 아닌 것으로 보인다.  

그러나 CPU 처리량이 한계를 초과하고 코어 수가 전체 스레드 수에 비해 부족해지면서 Context Switching 비용이 증가했고,   
이로 인해 서버 로직 처리 지연이 발생한 것으로 판단된다.

이러한 처리 지연의 영향으로 일부 클라이언트 연결이 끊어지는 문제가 나타났다.  
로컬 환경에서 진행된 테스트였기 때문에 네트워크 대역폭이 원인은 아닐 가능성이 높다.  
로그를 분석한 결과, 소켓이 먼저 종료된 흔적이 확인되었으며 이는 커널 레벨에서 연결이 종료된 것으로 추정된다.  
CPU 부하만으로 소켓이 직접 강제로 종료되지는 않지만,  
CPU 포화로 인해 서버의 I/O 처리 주기가 지연되면서(Overlapped Pool 소모가 관측됨) 수신/송신 버퍼가 일정 시간 이상 초과 상태가 되었고,    
이로 인해 일부 소켓 세션이 커널에 의해 종료된 것으로 판단된다.

## 4.추후 개선 사항
1개의 서버에 5000명의 클라이언트 테스트를 통과하기 위해 필요한 것
1. 서버 분리
	1. 로그인 서버, Redis, 모니터링 도구, 게임 서버를 분리하여 CPU 및 I/O 경쟁을 제거해야 한다.
1. 패킷 대역폭 최적화
	1. Full 패킷에서 Name 필드를 제거하고, 별도 로드 방식으로 변경하여 패킷 크기를 경량화해야 한다.
	1. Full 패킷 발송 주기를 5~7초 수준으로 늘려 전체 대역폭을 줄인다.
	1. 현재는 grid 기반의 단순 AOI를 사용하지만, CPU 사이클을 더 사용하더라도 대역폭 절감을 위한 AOI 알고리즘 적용이 필요하다.
1. Zone 전환 로직 개선
	1. 현재는 None Zone 핸들러에서 zone 전환 요청을 받으면 zone thread에 lock을 걸어 전환을 처리하고 있다.
	1. 각 zone에 작업 큐를 두어 mutex 없이 작업큐를 통해 비동기적으로 처리되도록 해야한다.
	1. zone 내부로직은 zone 전환을 제외하고는 싱글스레드 접근이라 모든 mutex를 제거할 수 있게된다.

## 5.참고자료
[DummyClient](DummyClients/Program.cs)